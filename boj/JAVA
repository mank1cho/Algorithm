/* Sort (int, String //  Compartor, Lambda) - 11650, 1181
 * stable Sort - 10814
 * back tracking basic - 15649 ~ 15652
 * 
 * 
 * 
 */

-------------------------------------------------------------------------------------------------------
Integer : 
parseInt(): 원시데이터인 int 타입을 반환
valueOf(): Integer 래퍼(wrapper)객체를 반환 (Boxing, 산술연산 못함)

parseInt는 산술연산이 가능하나 null 초기화가 불가능하다.
vlaueOf는 wrapper class로서 산술연산이 불가능하지만 null 처리가 가능하므로 SQL연동 시 사용될 수 있다.

java wrapper Class : Short, Integer, Long, Float, Double, BigInteger, BigDecimal
-------------------------------------------------------------------------------------------------------
String :

		String str1 = "string";
		String str2 = "string";
		String str3 = new String(string);
		String str4 = new String(string);
		str1과 str2는 같은 주소값을 가짐.
		str3과 str4는 새로운 객체를 생성한 것이므로 다른 주소값을 가짐.
		하지만 모든 문자열의 hashcode는 동일함.
		hashCode : 객체를 저장하는 hash table에서 각 객체에 대응되는 고유한 정수값.
		String 클래스는 내부적으로 hashCode 메서드를 재정의하여 같은 hashCode를 갖도록 설정되어있다.

		== 연산자는 같은 주소인지를 판별함
		equals는 같은 내용인지를 판별함.
		
		equals(Object)메소드가 true이면 두 객체의 hashCode 값은 같아야 한다.
		equals(Object)메소드가 false이면 두 객체의 hashCode가 꼭 다를 필요는 없다. (즉 내용이 달라도 hash code가 같을 수 있다.)
		하지만 서로 다른 hashCode 값이 나오면 해시 테이블(hash table)의 성능이 향상될 수 있다는 점은 이해하고 있어야 한다.
		
		참고
		https://gbsb.tistory.com/255
		https://blog.naver.com/travelmaps/220930144030
				
		----		
		일반 String과 StringBuilder, StringBuffer의 차이점 : String은 새로운 값을 할당할 때마다 새로 생성됨.
		+연산자로 문자열을 이어붙일때마다 새로운 String이 생성되므로 메모리 관리 측면에서 적절하지 않음. java에서 대표적인 immutable한 객체임.
		
		StringBuilder와 StringBuffer는 mutable한 객체이다. 문자열을 이어붙일 수 있다.
		*JDK 1.5 버전 이후에는 String 객체를 사용하더라도 컴파일 단계에서 StringBuilder로 컴파일하도록 변경되었다.
		
		StringBuilder 와 StringBuffer의 가장 큰 차이점 : Thread-safe.
		StringBuilder는 Thread-safe하지 않다.
		StringBuffer는 Thread-safe하다.
		
		참고 https://novemberde.github.io/2017/04/15/String_0.html
		
		
		//String 자리수 맞추기.
		int user_no = 30;
		String result_user_no = String.format("%04d", user_no);
		result_user_no 는 0030이 된다.
		%-명령시작, 0-채워질 문자, 4-총자리수, d-십진정수
		
		//소수점 아래 precision 설정
		String.format("%.3f", double or float)
		
		//Math.round()와 String.format()차이점 
		위 메서드들은 실수를 소수점 n번째까지 잘라서 표현한다는 공통점이 있다. 
		하지만 두개의 메서드가 꼭 같은 결과값을 출력하지는 않는다. 
		Math.round()함수는 소수점아래가 0일경우 절삭하지만 String.format은 절삭하지 않고 그대로 리턴한다.
		
		예)
		double money = 5000.000;
		System.out.println(Math.round(money*1000)/1000); //결과 5000
		System.out.println(String.format("%.3f", money)); //결과 : 5000.000

-------------------------------------------------------------------------------------------------------	
/* BigDecimal(소수점 아래 '최대' precision 설정, (0은 출력 안됨))
Double ans = BigDecimal.valueOf(double)
.setScale(3, RoundingMode.HALF_UP)
.doubleValue();
*/		

-------------------------------------------------------------------------------------------------------
compare 예제

-----------int--------------
		int[][] arr = new String[N][2];
		
		Arrays.sort(arr, new Comparator<int[]>() {
			@Override
			public int compare(int[] e1, int[] e2) {
				if(e1[1] == e2[1]) {
					return e1[0] - e2[0];
				} else {
					return e1[1] - e2[1];
				}
			}
		});
		
*lambda		
		Arrays.sort(arr, (e1, e2) -> {	// int[] e1, int[] e2 가 정석인데 타입이 생략됨.
			if(e1[1] == e2[1]) {
				return e1[0] - e2[0];
			} else {
				return e1[1] - e2[1];
			}
		});
		
----------string-------------
		String[] arr = new String[N];
		
		Arrays.sort(arr, new Comparator<String>() {
			@Override
			public int compare(String s1, String s2) {
				if(s1.length() == s2.length()) {
					return s1.compareTo(s2);
				}
				else {
					return s1.length() - s2.length();
				}
			}
		});
		
*lambda
		Arrays.sort(arr, (String s1, String s2) -> {
			if(s1.length() == s2.length()) {
				return s1.compareTo(s2);
			}
			else
				return s1.length() - s2.length();
		});
-------------------------------------------------------------------------------------------------------		